{"version":3,"file":"index.mjs","sources":["../lib/assign.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isComplexDataType from '@stdlib/array-base-assert-is-complex-floating-point-data-type';\nimport isBooleanDataType from '@stdlib/array-base-assert-is-boolean-data-type';\nimport arraylike2object from '@stdlib/array-base-arraylike2object';\nimport reinterpret from '@stdlib/strided-base-reinterpret-complex';\nimport reinterpretBoolean from '@stdlib/strided-base-reinterpret-boolean';\nimport normalizeIndex from '@stdlib/ndarray-base-normalize-index';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// FUNCTIONS //\n\n/**\n* Copies every element from one array to another array, except for the element at a specified index.\n*\n* @private\n* @param {Collection} x - input array\n* @param {integer} index - element index\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0 ];\n* var arr = indexed( x, 0, out, 1, 0 );\n* // returns [ 2, 3, 4 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\nfunction indexed( x, index, out, stride, offset ) {\n\tvar io;\n\tvar i;\n\n\tio = offset;\n\tfor ( i = 0; i < x.length; i++ ) {\n\t\tif ( i === index ) {\n\t\t\tcontinue;\n\t\t}\n\t\tout[ io ] = x[ i ];\n\t\tio += stride;\n\t}\n\treturn out;\n}\n\n/**\n* Copies every element from one accessor array to another accessor array, except for the element at a specified index.\n*\n* @private\n* @param {Object} x - input array object\n* @param {integer} index - element index\n* @param {Object} out - output array object\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import arraylike2object from '@stdlib/array-base-arraylike2object';\n*\n* var x = toAccessorArray( [ 1, 2, 3, 4 ] );\n*\n* var out = toAccessorArray( [ 0, 0, 0 ] );\n* var arr = accessors( arraylike2object( x ), 0, arraylike2object( out ), 1, 0 );\n*\n* var v = arr.get( 0 );\n* // returns 2\n*/\nfunction accessors( x, index, out, stride, offset ) {\n\tvar xdata;\n\tvar odata;\n\tvar xget;\n\tvar oset;\n\tvar io;\n\tvar i;\n\n\txdata = x.data;\n\todata = out.data;\n\n\txget = x.accessors[ 0 ];\n\toset = out.accessors[ 1 ];\n\n\tio = offset;\n\tfor ( i = 0; i < xdata.length; i++ ) {\n\t\tif ( i === index ) {\n\t\t\tcontinue;\n\t\t}\n\t\toset( odata, io, xget( xdata, i ) );\n\t\tio += stride;\n\t}\n\treturn odata;\n}\n\n/**\n* Copies every element from one complex array to another complex array, except for the element at a specified index.\n*\n* @private\n* @param {Collection} x - real-valued floating-point input array view\n* @param {integer} index - element index\n* @param {Collection} out - real-valued floating-point output array view\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array view\n*\n* @example\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import Float64Array from '@stdlib/array-float64';\n* import arraylike2object from '@stdlib/array-base-arraylike2object';\n*\n* var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* var out = new Float64Array( 2 );\n* var arr = complex( x, 0, out, 1, 0 );\n* // returns <Float64Array>[ 3.0, 4.0 ]\n*/\nfunction complex( x, index, out, stride, offset ) {\n\tvar so;\n\tvar io;\n\tvar i;\n\tvar j;\n\n\tso = stride * 2; // multiply by 2, as real-valued array consists of interleaved real and imaginary components\n\tio = offset * 2;\n\tfor ( i = 0; i < x.length/2; i++ ) {\n\t\tif ( i === index ) {\n\t\t\tcontinue;\n\t\t}\n\t\tj = i * 2;\n\t\tout[ io ] = x[ j ];\n\t\tout[ io+1 ] = x[ j+1 ];\n\t\tio += so;\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Copies every element from one array to another array, except for the element at a specified index.\n*\n* @param {Collection} x - input array\n* @param {integer} index - element index\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @throws {RangeError} second argument must not exceed array bounds\n* @returns {Collection} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0 ];\n* var arr = assign( x, 0, out, 1, 0 );\n* // returns [ 2, 3, 4 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\nfunction assign( x, index, out, stride, offset ) {\n\tvar xo;\n\tvar oo;\n\n\tindex = normalizeIndex( index, x.length-1 );\n\tif ( index < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Index argument is out-of-bounds. Value: `%d`.', index ) );\n\t}\n\txo = arraylike2object( x );\n\too = arraylike2object( out );\n\tif ( xo.accessorProtocol || oo.accessorProtocol ) {\n\t\t// Note: we only explicitly support a limited set of dtype-to-dtype pairs, as this function should not be concerned with casting rules, etc. That is left to userland...\n\t\tif (\n\t\t\tisComplexDataType( xo.dtype ) &&\n\t\t\tisComplexDataType( oo.dtype )\n\t\t) {\n\t\t\tcomplex( reinterpret( x, 0 ), index, reinterpret( out, 0 ), stride, offset ); // eslint-disable-line max-len\n\t\t\treturn out;\n\t\t}\n\t\tif (\n\t\t\tisBooleanDataType( xo.dtype ) &&\n\t\t\tisBooleanDataType( oo.dtype )\n\t\t) {\n\t\t\tindexed( reinterpretBoolean( x, 0 ), index, reinterpretBoolean( out, 0 ), stride, offset ); // eslint-disable-line max-len\n\t\t\treturn out;\n\t\t}\n\t\taccessors( xo, index, oo, stride, offset );\n\t\treturn out;\n\t}\n\tindexed( x, index, out, stride, offset );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default assign;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport normalizeIndex from '@stdlib/ndarray-base-normalize-index';\nimport zeros from '@stdlib/array-zeros';\nimport dtype from '@stdlib/array-dtype';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport assign from './assign.js';\n\n\n// MAIN //\n\n/**\n* Returns a new array containing every element from an input array, except for the element at a specified index.\n*\n* @param {Collection} x - input array\n* @param {integer} index - element index\n* @throws {RangeError} second argument must not exceed array bounds\n* @returns {Collection} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n*\n* var v = without( x, 0 );\n* // returns [ 2, 3, 4 ]\n*\n* v = without( x, 1 );\n* // returns [ 1, 3, 4 ]\n*\n* v = without( x, -2 );\n* // returns  [ 1, 2, 4 ]\n*/\nfunction without( x, index ) {\n\tvar out;\n\n\tindex = normalizeIndex( index, x.length-1 );\n\tif ( index < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Index argument is out-of-bounds. Value: `%d`.', index ) );\n\t}\n\tout = zeros( x.length-1, dtype( x ) || 'generic' );\n\tassign( x, index, out, 1, 0 );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default without;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return a new array containing every element from an input array, except for the element at a specified index.\n*\n* @module @stdlib/array-base-without\n*\n* @example\n* import without from '@stdlib/array-base-without';\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* var v = without( x, 0 );\n* // returns [ 2, 3, 4 ]\n*\n* v = without( x, -2 );\n* // returns [ 1, 2, 4 ]\n*\n* @example\n* import without from '@stdlib/array-base-without';\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0 ];\n* var arr = without.assign( x, 0, out, 1, 0 );\n* // returns [ 2, 3, 4 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport assign from './assign.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["indexed","x","index","out","stride","offset","io","i","length","assign","xo","oo","normalizeIndex","RangeError","format","arraylike2object","accessorProtocol","isComplexDataType","dtype","so","j","complex","reinterpret","isBooleanDataType","reinterpretBoolean","xdata","odata","xget","oset","data","accessors","without","zeros","setReadOnly","main"],"mappings":";;yhCAsDA,SAASA,EAASC,EAAGC,EAAOC,EAAKC,EAAQC,GACxC,IAAIC,EACAC,EAGJ,IADAD,EAAKD,EACCE,EAAI,EAAGA,EAAIN,EAAEO,OAAQD,IACrBA,IAAML,IAGXC,EAAKG,GAAOL,EAAGM,GACfD,GAAMF,GAEP,OAAOD,CACR,CAoHA,SAASM,EAAQR,EAAGC,EAAOC,EAAKC,EAAQC,GACvC,IAAIK,EACAC,EAGJ,IADAT,EAAQU,EAAgBV,EAAOD,EAAEO,OAAO,IAC3B,EACZ,MAAM,IAAIK,WAAYC,EAAQ,kEAAmEZ,IAIlG,OAFAQ,EAAKK,EAAkBd,GACvBU,EAAKI,EAAkBZ,GAClBO,EAAGM,kBAAoBL,EAAGK,iBAG7BC,EAAmBP,EAAGQ,QACtBD,EAAmBN,EAAGO,QA1DzB,SAAkBjB,EAAGC,EAAOC,EAAKC,EAAQC,GACxC,IAAIc,EACAb,EACAC,EACAa,EAIJ,IAFAD,EAAc,EAATf,EACLE,EAAc,EAATD,EACCE,EAAI,EAAGA,EAAIN,EAAEO,OAAO,EAAGD,IACvBA,IAAML,IAGXkB,EAAQ,EAAJb,EACJJ,EAAKG,GAAOL,EAAGmB,GACfjB,EAAKG,EAAG,GAAML,EAAGmB,EAAE,GACnBd,GAAMa,EAGR,CA0CGE,CAASC,EAAarB,EAAG,GAAKC,EAAOoB,EAAanB,EAAK,GAAKC,EAAQC,GAC7DF,GAGPoB,EAAmBb,EAAGQ,QACtBK,EAAmBZ,EAAGO,QAEtBlB,EAASwB,EAAoBvB,EAAG,GAAKC,EAAOsB,EAAoBrB,EAAK,GAAKC,EAAQC,GAC3EF,IAnHV,SAAoBF,EAAGC,EAAOC,EAAKC,EAAQC,GAC1C,IAAIoB,EACAC,EACAC,EACAC,EACAtB,EACAC,EASJ,IAPAkB,EAAQxB,EAAE4B,KACVH,EAAQvB,EAAI0B,KAEZF,EAAO1B,EAAE6B,UAAW,GACpBF,EAAOzB,EAAI2B,UAAW,GAEtBxB,EAAKD,EACCE,EAAI,EAAGA,EAAIkB,EAAMjB,OAAQD,IACzBA,IAAML,IAGX0B,EAAMF,EAAOpB,EAAIqB,EAAMF,EAAOlB,IAC9BD,GAAMF,EAGR,CA8FE0B,CAAWpB,EAAIR,EAAOS,EAAIP,EAAQC,GAC3BF,IAERH,EAASC,EAAGC,EAAOC,EAAKC,EAAQC,GACzBF,EACR,CCnKA,SAAS4B,EAAS9B,EAAGC,GACpB,IAAIC,EAGJ,IADAD,EAAQU,EAAgBV,EAAOD,EAAEO,OAAO,IAC3B,EACZ,MAAM,IAAIK,WAAYC,EAAQ,kEAAmEZ,IAIlG,OADAO,EAAQR,EAAGC,EADXC,EAAM6B,EAAO/B,EAAEO,OAAO,EAAGU,EAAOjB,IAAO,WAChB,EAAG,GACnBE,CACR,CCHA8B,EAAAC,EAAA,SAAAzB"}